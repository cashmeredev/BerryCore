#!/bin/sh
# qpkg - QNX Package Manager for BerryCore
# Manage BerryCore updates and install additional ports

VERSION="0.1.0"
GITHUB_REPO="sw7ft/BerryCore"
GITHUB_API="https://api.github.com/repos/$GITHUB_REPO"
GITHUB_RAW="https://raw.githubusercontent.com/$GITHUB_REPO/main"
DOWNLOAD_DIR="/accounts/1000/shared/documents"

# Colors (if terminal supports it)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    BOLD='\033[1m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    BOLD=''
    NC=''
fi

# Helper functions
print_header() {
    echo ""
    echo "==========================================="
    echo "  $1"
    echo "==========================================="
    echo ""
}

print_success() {
    echo "${GREEN}✓${NC} $1"
}

print_error() {
    echo "${RED}✗${NC} $1"
}

print_info() {
    echo "${BLUE}ℹ${NC} $1"
}

print_warning() {
    echo "${YELLOW}⚠${NC} $1"
}

# Get current installed version
get_current_version() {
    if [ -f "$NATIVE_TOOLS/VERSION" ]; then
        cat "$NATIVE_TOOLS/VERSION"
    else
        echo "unknown"
    fi
}

# Check for updates via GitHub API
check_for_updates() {
    print_info "Checking for updates..."
    
    # Fetch latest release info
    RELEASE_JSON=$(curl -s -k -m 10 "$GITHUB_API/releases/latest" 2>/dev/null)
    
    if [ -z "$RELEASE_JSON" ]; then
        print_error "Failed to connect to GitHub. Check your internet connection."
        return 1
    fi
    
    # Parse version tag (remove 'v' prefix)
    LATEST_VERSION=$(echo "$RELEASE_JSON" | grep '"tag_name"' | sed 's/.*"v\([^"]*\)".*/\1/' | head -1)
    
    if [ -z "$LATEST_VERSION" ]; then
        print_error "Could not determine latest version."
        return 1
    fi
    
    echo "$LATEST_VERSION"
}

# Compare versions (handles x.y and x.y.z)
version_greater() {
    # $1 = new version, $2 = old version
    # Returns 0 if $1 > $2
    
    # Handle both x.y and x.y.z formats
    NEW_MAJOR=$(echo "$1" | cut -d. -f1)
    NEW_MINOR=$(echo "$1" | cut -d. -f2)
    NEW_PATCH=$(echo "$1" | cut -d. -f3)
    OLD_MAJOR=$(echo "$2" | cut -d. -f1)
    OLD_MINOR=$(echo "$2" | cut -d. -f2)
    OLD_PATCH=$(echo "$2" | cut -d. -f3)
    
    # Default to 0 if patch version doesn't exist
    [ -z "$NEW_PATCH" ] && NEW_PATCH=0
    [ -z "$OLD_PATCH" ] && OLD_PATCH=0
    
    # Compare major version
    if [ "$NEW_MAJOR" -gt "$OLD_MAJOR" ]; then
        return 0
    elif [ "$NEW_MAJOR" -lt "$OLD_MAJOR" ]; then
        return 1
    fi
    
    # Major same, compare minor
    if [ "$NEW_MINOR" -gt "$OLD_MINOR" ]; then
        return 0
    elif [ "$NEW_MINOR" -lt "$OLD_MINOR" ]; then
        return 1
    fi
    
    # Major and minor same, compare patch
    if [ "$NEW_PATCH" -gt "$OLD_PATCH" ]; then
        return 0
    else
        return 1
    fi
}

# Download file with progress
download_file() {
    URL="$1"
    OUTPUT="$2"
    FILENAME=$(basename "$OUTPUT")
    
    print_info "Downloading $FILENAME..."
    
    # Try curl with progress bar
    if command -v curl >/dev/null 2>&1; then
        curl -k -L -o "$OUTPUT" "$URL" 2>&1 | \
        while read line; do
            echo "$line" | grep -o '[0-9]*\.[0-9]' | tail -1 | \
            while read pct; do
                printf "\r  Progress: %.0f%%" "$pct"
            done
        done
        printf "\r  Progress: 100%%\n"
    elif command -v wget >/dev/null 2>&1; then
        wget -O "$OUTPUT" "$URL"
    else
        print_error "No download tool available (curl or wget required)"
        return 1
    fi
    
    if [ -f "$OUTPUT" ]; then
        print_success "Downloaded $FILENAME"
        return 0
    else
        print_error "Download failed: $FILENAME"
        return 1
    fi
}

# Update BerryCore
cmd_update() {
    print_header "BerryCore Update Manager"
    
    CURRENT_VERSION=$(get_current_version)
    echo "Current version: ${BOLD}v${CURRENT_VERSION}${NC}"
    echo ""
    
    LATEST_VERSION=$(check_for_updates)
    if [ $? -ne 0 ]; then
        exit 1
    fi
    
    echo "Latest version:  ${BOLD}v${LATEST_VERSION}${NC}"
    echo ""
    
    # Compare versions
    if [ "$CURRENT_VERSION" = "$LATEST_VERSION" ]; then
        print_success "You're already on the latest version!"
        exit 0
    fi
    
    if ! version_greater "$LATEST_VERSION" "$CURRENT_VERSION"; then
        print_info "Your version ($CURRENT_VERSION) is newer than the release ($LATEST_VERSION)"
        exit 0
    fi
    
    # New version available
    print_success "New version available: v${LATEST_VERSION}"
    echo ""
    
    # Fetch release notes
    RELEASE_BODY=$(curl -s -k "$GITHUB_API/releases/latest" | grep -A 50 '"body"' | sed '1d' | sed 's/^[[:space:]]*"//' | head -20)
    if [ -n "$RELEASE_BODY" ]; then
        echo "${BOLD}What's new:${NC}"
        echo "$RELEASE_BODY" | head -10
        echo ""
    fi
    
    # Confirm update
    echo -n "Download and install v${LATEST_VERSION}? [Y/n]: "
    read CONFIRM
    
    if [ "$CONFIRM" != "" ] && [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
        echo "Update cancelled."
        exit 0
    fi
    
    echo ""
    print_header "Downloading BerryCore v${LATEST_VERSION}"
    
    # Download URLs
    BERRYCORE_URL="https://github.com/$GITHUB_REPO/releases/download/v${LATEST_VERSION}/berrycore.zip"
    INSTALL_URL="https://github.com/$GITHUB_REPO/releases/download/v${LATEST_VERSION}/install.sh"
    
    # Create download directory and temp dir
    mkdir -p "$DOWNLOAD_DIR" 2>/dev/null
    UPDATE_DIR="$DOWNLOAD_DIR/.berrycore-update-$$"
    mkdir -p "$UPDATE_DIR"
    
    # Save current directory to return later
    ORIG_DIR="$PWD"
    
    # Download files to temp directory
    cd "$UPDATE_DIR" || exit 1
    
    download_file "$BERRYCORE_URL" "berrycore.zip"
    if [ $? -ne 0 ]; then
        print_error "Failed to download berrycore.zip"
        cd "$ORIG_DIR"
        rm -rf "$UPDATE_DIR"
        exit 1
    fi
    
    download_file "$INSTALL_URL" "install.sh"
    if [ $? -ne 0 ]; then
        print_error "Failed to download install.sh"
        cd "$ORIG_DIR"
        rm -rf "$UPDATE_DIR"
        exit 1
    fi
    
    chmod +x install.sh
    
    echo ""
    print_header "Installing BerryCore v${LATEST_VERSION}"
    echo ""
    print_info "This may take a minute, please wait..."
    echo ""
    
    # Run installer with auto-confirm (pipe empty lines for prompts)
    # The install.sh will:
    # 1. Use default directory (berrycore)
    # 2. Use upgrade mode (choice 1) 
    # 3. Auto-continue
    printf "\n\n1\n" | sh ./install.sh
    INSTALL_EXIT=$?
    
    # Clean up
    cd "$ORIG_DIR"
    rm -rf "$UPDATE_DIR"
    
    if [ $INSTALL_EXIT -eq 0 ]; then
        echo ""
        print_success "BerryCore updated to v${LATEST_VERSION}!"
        echo ""
        echo "Changes will take effect in new shells."
        echo "To use now, run: ${GREEN}source $NATIVE_TOOLS/env.sh${NC}"
        echo ""
    else
        print_error "Installation failed. Check errors above."
        exit 1
    fi
}

# List available ports from repository
cmd_ports() {
    print_header "Available Ports"
    
    print_info "Fetching ports index from GitHub..."
    echo ""
    
    # Fetch INDEX file from GitHub
    INDEX_URL="$GITHUB_RAW/ports/INDEX"
    
    # Try with increased timeout and show errors
    # Use -k to bypass SSL cert issues on BB10/QNX with missing certs
    INDEX_CONTENT=$(curl -s -k -L -m 15 "$INDEX_URL" 2>&1)
    CURL_EXIT=$?
    
    if [ $CURL_EXIT -ne 0 ] || [ -z "$INDEX_CONTENT" ]; then
        print_error "Failed to fetch ports index from GitHub (curl exit code: $CURL_EXIT)"
        echo ""
        echo "Error output:"
        echo "$INDEX_CONTENT" | head -3
        echo ""
        echo "Try manually:"
        echo "  curl -v '$INDEX_URL'"
        echo ""
        echo "Or visit: https://github.com/$GITHUB_REPO/tree/main/ports"
        exit 1
    fi
    
    {
        echo "Available ports to install:"
        echo "==========================================================="
        echo ""
        
        # Parse and display INDEX
        echo "$INDEX_CONTENT" | grep -v "^#" | grep -v "^$" | while IFS='|' read -r name cat ver size desc; do
            printf "  ${GREEN}%-20s${NC} ${BLUE}[%s]${NC} v%-6s %-6s %s\n" "$name" "$cat" "$ver" "$size" "$desc"
        done
        
        echo ""
        echo "Install with: ${GREEN}qpkg install <port-name>${NC}"
        echo ""
    } | paginate
}

# Install a port
cmd_install() {
    PORT_NAME="$1"
    
    if [ -z "$PORT_NAME" ]; then
        print_error "Usage: qpkg install <package-name>"
        exit 1
    fi
    
    print_header "Installing Port: $PORT_NAME"
    
    # Fetch INDEX to find the port
    print_info "Searching for port: $PORT_NAME"
    INDEX_URL="$GITHUB_RAW/ports/INDEX"
    # Use -k to bypass SSL cert issues on BB10/QNX with missing certs
    INDEX_CONTENT=$(curl -s -k -L -m 15 "$INDEX_URL" 2>&1)
    CURL_EXIT=$?
    
    if [ $CURL_EXIT -ne 0 ] || [ -z "$INDEX_CONTENT" ]; then
        print_error "Failed to fetch ports index from GitHub (curl exit code: $CURL_EXIT)"
        echo ""
        echo "Error: $INDEX_CONTENT" | head -3
        echo ""
        echo "Try: curl -v '$INDEX_URL'"
        exit 1
    fi
    
    # Find port in INDEX
    PORT_INFO=$(echo "$INDEX_CONTENT" | grep -v "^#" | grep "^$PORT_NAME|")
    
    if [ -z "$PORT_INFO" ]; then
        print_error "Port '$PORT_NAME' not found in repository"
        echo ""
        echo "Available ports:"
        echo "$INDEX_CONTENT" | grep -v "^#" | grep -v "^$" | cut -d'|' -f1 | sed 's/^/  /'
        echo ""
        echo "Or run: qpkg ports"
        exit 1
    fi
    
    # Parse port info
    CATEGORY=$(echo "$PORT_INFO" | cut -d'|' -f2)
    VERSION=$(echo "$PORT_INFO" | cut -d'|' -f3)
    SIZE=$(echo "$PORT_INFO" | cut -d'|' -f4)
    DESCRIPTION=$(echo "$PORT_INFO" | cut -d'|' -f5)
    
    # Construct filename and URL
    FILENAME="${CATEGORY}-${PORT_NAME}-${VERSION}.zip"
    DOWNLOAD_URL="$GITHUB_RAW/ports/$FILENAME"
    
    echo ""
    echo "Port: $PORT_NAME v$VERSION"
    echo "Category: $CATEGORY"
    echo "Size: $SIZE"
    echo "Description: $DESCRIPTION"
    echo ""
    echo "Download URL: $DOWNLOAD_URL"
    echo ""
    echo -n "Install this port? [Y/n]: "
    read CONFIRM
    
    if [ "$CONFIRM" != "" ] && [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
        echo "Installation cancelled."
        exit 0
    fi
    
    # Create temp directory in NATIVE_TOOLS (QNX /tmp may not be writable)
    TEMP_DIR="$NATIVE_TOOLS/.tmp/qpkg-$PORT_NAME-$$"
    mkdir -p "$TEMP_DIR"
    
    # Download port
    echo ""
    print_info "Downloading $FILENAME..."
    
    if ! curl -k -L -o "$TEMP_DIR/$FILENAME" "$DOWNLOAD_URL" 2>&1 | grep -o '[0-9]*\.[0-9]' | tail -1 | while read pct; do printf "\r  Progress: %.0f%%" "$pct"; done; then
        printf "\r  Progress: 100%%\n"
        print_error "Download failed"
        rm -rf "$TEMP_DIR"
        exit 1
    fi
    printf "\n"
    
    # Verify download
    if [ ! -f "$TEMP_DIR/$FILENAME" ]; then
        print_error "Downloaded file not found"
        rm -rf "$TEMP_DIR"
        exit 1
    fi
    
    print_success "Downloaded $FILENAME"
    
    # Install (extract to NATIVE_TOOLS)
    echo ""
    print_info "Installing to $NATIVE_TOOLS..."
    
    cd "$NATIVE_TOOLS" || exit 1
    
    if unzip -o "$TEMP_DIR/$FILENAME" 2>&1 | grep -v "Archive:" | grep -v "inflating:"; then
        :
    fi
    
    # Set executable permissions on binaries
    if [ -d "$NATIVE_TOOLS/bin" ]; then
        chmod +x "$NATIVE_TOOLS/bin"/* 2>/dev/null
    fi
    
    # Set executable permissions on Python binaries (if this is Python)
    if [ "$PORT_NAME" = "python3" ] && [ -d "$NATIVE_TOOLS/lib/python3.11/tools/python3" ]; then
        chmod +x "$NATIVE_TOOLS/lib/python3.11/tools/python3"/* 2>/dev/null
    fi
    
    echo ""
    print_success "Port '$PORT_NAME' installed successfully!"
    echo ""
    
    # Show installed binaries (before cleanup)
    if [ -d "$NATIVE_TOOLS/bin" ]; then
        echo "Binaries installed:"
        ls -1 "$NATIVE_TOOLS/bin" | tail -10 | sed 's/^/  /'
    fi
    
    # Clean up
    rm -rf "$TEMP_DIR"
    
    echo ""
}

# Search for ports (future implementation)
cmd_search() {
    SEARCH_TERM="$1"
    
    if [ -z "$SEARCH_TERM" ]; then
        print_error "Usage: qpkg search <keyword>"
        exit 1
    fi
    
    print_header "Searching Ports"
    
    print_info "Feature coming soon!"
    echo ""
    echo "This will search the ports repository for: $SEARCH_TERM"
}

# List installed packages
cmd_list() {
    print_header "Installed Packages"
    
    if [ -d "$NATIVE_TOOLS/packages" ]; then
        ls -1 "$NATIVE_TOOLS/packages/" | sed 's/.zip$//' | nl
    else
        print_error "Packages directory not found"
    fi
}

# Show package/binary info
cmd_info() {
    BINARY="$1"
    
    if [ -z "$BINARY" ]; then
        print_error "Usage: qpkg info <binary-name>"
        exit 1
    fi
    
    print_header "Binary Info: $BINARY"
    
    # Check if binary exists in bin/
    if [ -f "$NATIVE_TOOLS/bin/$BINARY" ]; then
        echo "Location: $NATIVE_TOOLS/bin/$BINARY"
        
        # Get info from catalog
        if [ -f "$NATIVE_TOOLS/CATALOG" ]; then
            INFO=$(grep "^$BINARY|" "$NATIVE_TOOLS/CATALOG" 2>/dev/null)
            if [ -n "$INFO" ]; then
                CATEGORY=$(echo "$INFO" | cut -d'|' -f2)
                DESCRIPTION=$(echo "$INFO" | cut -d'|' -f3)
                echo "Category: $CATEGORY"
                echo "Description: $DESCRIPTION"
            fi
        fi
        
        # Show file info
        echo ""
        ls -lh "$NATIVE_TOOLS/bin/$BINARY" | awk '{print "Size: " $5 "  Permissions: " $1}'
        
        # Try to get version
        echo ""
        if "$NATIVE_TOOLS/bin/$BINARY" --version 2>/dev/null | head -1; then
            :
        elif "$NATIVE_TOOLS/bin/$BINARY" -v 2>/dev/null | head -1; then
            :
        else
            echo "Version: (unknown)"
        fi
        
        # Check for man page
        echo ""
        if [ -f "$NATIVE_TOOLS/man/man1/$BINARY.1" ] || [ -f "$NATIVE_TOOLS/share/man/man1/$BINARY.1" ]; then
            echo "Manual: Available (run 'man $BINARY')"
        else
            echo "Manual: Not available"
        fi
        
        echo ""
    else
        # Check if it's a package
        if [ -f "$NATIVE_TOOLS/packages/${BINARY}.zip" ]; then
            echo "Package: ${BINARY}.zip"
            SIZE=$(ls -lh "$NATIVE_TOOLS/packages/${BINARY}.zip" | awk '{print $5}')
            echo "Size: $SIZE"
            print_success "Installed: Yes"
        else
            print_error "Binary or package '$BINARY' not found"
            echo ""
            echo "Try: qpkg catalog -s $BINARY"
            exit 1
        fi
    fi
}

# Pagination helper
paginate() {
    # Use less with smart options:
    # -F: quit if one screen
    # -X: don't clear screen on exit
    # -R: allow ANSI colors
    # -S: chop long lines (don't wrap)
    if command -v less >/dev/null 2>&1; then
        less -FXR
    else
        cat
    fi
}

# Show binary catalog
cmd_catalog() {
    CATALOG="$NATIVE_TOOLS/CATALOG"
    
    if [ ! -f "$CATALOG" ]; then
        print_error "Catalog file not found: $CATALOG"
        exit 1
    fi
    
    # Parse options
    MODE="list"
    ARG=""
    
    case "$1" in
        -c|--category)
            MODE="category"
            ARG="$2"
            if [ -z "$ARG" ]; then
                print_error "Usage: qpkg catalog -c <category>"
                exit 1
            fi
            ;;
        -s|--search)
            MODE="search"
            ARG="$2"
            if [ -z "$ARG" ]; then
                print_error "Usage: qpkg catalog -s <search-term>"
                exit 1
            fi
            ;;
        -h|--help)
            cat << 'HELPEOF'

Binary Catalog - Browse available binaries

Usage:
  qpkg catalog              List all binaries by category
  qpkg catalog -c CATEGORY  List binaries in specific category
  qpkg catalog -s TERM      Search for binaries

Categories:
  dev, shell, editor, util, net, sys, archive, media, data,
  x11, js, lang, security, time, comm, game, doc, build, calc,
  todo, emu

Examples:
  qpkg catalog           # Show all binaries
  qpkg catalog -c net    # Show networking tools
  qpkg catalog -s ssh    # Search for SSH-related tools

HELPEOF
            exit 0
            ;;
        "")
            MODE="list"
            ;;
        *)
            # Treat as search term
            MODE="search"
            ARG="$1"
            ;;
    esac
    
    # Generate output and paginate
    {
        case "$MODE" in
            list)
                echo ""
                printf "${BOLD}Available BerryCore Binaries${NC}\n"
                echo "==========================================================="
                echo ""
                
                current_cat=""
                grep -v "^#" "$CATALOG" | grep -v "^$" | sort -t'|' -k2,2 -k1,1 | while IFS='|' read -r name cat desc; do
                    if [ "$cat" != "$current_cat" ]; then
                        current_cat="$cat"
                        echo ""
                        printf "${YELLOW}[$cat]${NC}\n"
                    fi
                    printf "  ${GREEN}%-25s${NC} %s\n" "$name" "$desc"
                done
                echo ""
                ;;
                
            category)
                echo ""
                printf "${BOLD}BerryCore Binaries - Category: $ARG${NC}\n"
                echo "==========================================================="
                echo ""
                
                RESULTS=$(grep -v "^#" "$CATALOG" | grep -v "^$" | while IFS='|' read -r name cat desc; do
                    if [ "$cat" = "$ARG" ]; then
                        printf "  ${GREEN}%-25s${NC} %s\n" "$name" "$desc"
                    fi
                done)
                
                if [ -z "$RESULTS" ]; then
                    echo "  No binaries found in category: $ARG"
                else
                    echo "$RESULTS"
                fi
                echo ""
                ;;
                
            search)
                echo ""
                printf "${BOLD}Search results for: $ARG${NC}\n"
                echo "==========================================================="
                echo ""
                
                RESULTS=$(grep -v "^#" "$CATALOG" | grep -v "^$" | grep -i "$ARG" | while IFS='|' read -r name cat desc; do
                    printf "  %-25s [%s] %s\n" "$name" "$cat" "$desc"
                done)
                
                if [ -z "$RESULTS" ]; then
                    echo "  No results found for: $ARG"
                else
                    echo "$RESULTS"
                fi
                echo ""
                ;;
        esac
    } | paginate
}

# List all installed binaries
cmd_bins() {
    {
        echo ""
        printf "${BOLD}Installed Binaries${NC}\n"
        echo "==========================================================="
        echo ""
        
        if [ -d "$NATIVE_TOOLS/bin" ]; then
            CATALOG="$NATIVE_TOOLS/CATALOG"
            ls -1 "$NATIVE_TOOLS/bin" | while read -r bin; do
                # Try to find it in catalog
                if [ -f "$CATALOG" ]; then
                    desc=$(grep "^$bin|" "$CATALOG" 2>/dev/null | cut -d'|' -f3)
                    if [ -n "$desc" ]; then
                        printf "  ${GREEN}%-25s${NC} %s\n" "$bin" "$desc"
                    else
                        printf "  ${GREEN}%-25s${NC}\n" "$bin"
                    fi
                else
                    printf "  ${GREEN}%-25s${NC}\n" "$bin"
                fi
            done
        else
            print_error "bin directory not found"
        fi
        echo ""
    } | paginate
}

# Show help
cmd_help() {
    cat << EOF

${BOLD}qpkg${NC} - QNX Package Manager for BerryCore

${BOLD}USAGE:${NC}
  qpkg <command> [arguments]

${BOLD}COMMANDS:${NC}
  ${GREEN}update${NC}              Check for and install BerryCore updates
  ${GREEN}ports${NC}               List available ports from repository
  ${GREEN}install${NC} <package>   Install a port package from repository
  ${GREEN}catalog${NC} [options]   Browse available binaries (replaces bclist)
  ${GREEN}bins${NC}                List all installed binaries (replaces bcbins)
  ${GREEN}info${NC} <binary>       Show binary information (replaces bcinfo)
  list                List installed packages
  help                Show this help message

${BOLD}CATALOG OPTIONS:${NC}
  qpkg catalog              List all binaries by category
  qpkg catalog -c net       Show networking tools only
  qpkg catalog -s ssh       Search for SSH-related tools

${BOLD}EXAMPLES:${NC}
  qpkg update                  # Update BerryCore to latest version
  qpkg catalog                 # Browse all available binaries
  qpkg catalog -s compress     # Search for compression tools
  qpkg bins                    # List all installed binaries
  qpkg info nano               # Show info about nano binary
  qpkg ports                   # List available ports
  qpkg install hydra           # Install hydra port from repository

${BOLD}REPOSITORY:${NC}
  https://github.com/$GITHUB_REPO

${BOLD}VERSION:${NC}
  qpkg $VERSION

EOF
}

# Main command dispatcher
main() {
    COMMAND="$1"
    shift
    
    case "$COMMAND" in
        update)
            cmd_update "$@"
            ;;
        ports)
            cmd_ports "$@"
            ;;
        install)
            cmd_install "$@"
            ;;
        catalog)
            cmd_catalog "$@"
            ;;
        bins)
            cmd_bins "$@"
            ;;
        info)
            cmd_info "$@"
            ;;
        search)
            cmd_search "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        "")
            print_error "No command specified"
            echo "Run 'qpkg help' for usage information"
            exit 1
            ;;
        *)
            print_error "Unknown command: $COMMAND"
            echo "Run 'qpkg help' for available commands"
            exit 1
            ;;
    esac
}

# Run main
main "$@"

